Math for Programmers
====================

This tutorial contains practical math for programmers who want to get stuff
done, as well as explanation chapters for those who get interested in how the
math works.


Basics and Explanations
~~~~~~~~~~~~~~~~~~~~~~~

This tutorial assumes that you know most things shown in the basics page. If
you don't, that's not a problem at all and you can just keep the basics page
open while you read the tutorial.

I explain how most things work here, but if I don't explain or prove something
you'll probably find it in the separate explanation chapter.

.. toctree::
   :maxdepth: 2

   basics
   explanations


Functions
~~~~~~~~~

Here's a typical math function:

.. math:: f(x)=2x
.. math:: f(6)=12

There is no special syntax for defining a function. All we have is the
equal sign, and when defining a function we just say that its value at x is
equal to something.

If you're familiar with a functional programming language like Haskell, then
you'll probably realize that the above math looks a lot like this Haskell
session:

.. code-block:: haskell

   Prelude> let f x = 2*x
   Prelude> f 6
   12
   Prelude>

If you're feeling like WTF is this, here's a Python session that should make
everything clear.

.. code-block:: python

   >>> def f(x):
   ...     return 2*x
   ...
   >>> f(6)
   12

Quick note about ``f(x)`` versus ``f x``: if you define your own function
called `f` or `g` you should use `f(x)`, but you can use some "special"
functions like `\sin x` or `\cos x` for historical reasons.

Also note that mathematicians prefer single-letter variable names because math
was originally written on paper, and writing long things by hand sucks. Again,
this doesn't apply to the "special" functions.


Basic Angle Stuff
~~~~~~~~~~~~~~~~~

.. admonition:: Problem

   The ball of a ball-and-paddle game is moving at the angle of 30° and
   it hits a wall at right. How should the angle change?

   .. image:: images/ballpaddle.png
      :align: center

Here ° is the degree sign, and 30° means 30 degrees. Degrees work so
that 360° is a full turn, 180° is a half turn, 90° is a quarter and so
on. It's also possible to measure angles in radians, but we'll look into
that later.

Note that both angles are measured up from a horizontal line. Measuring
them like that is a standard that this tutorial uses and people are
familiar with. You can also measure angles that go down like that; for
example, 270° would be straight down (that's 90° less than a full turn).

We can solve our problem by taking the 30° angle sign and moving it like
this:

.. image:: images/ballpaddle2.png

Now you can see that the angles add up to half turn (or 180°), so we get
this :ref:`equation <equations>`:

.. math:: 30° + \text{???} = 180°
.. math:: \text{???} = 180° - 30° = 150°

In math it's common to use a letter instead of "???" to represent an
unknown value. For example:

.. math:: 30° + t = 180°
.. math:: t = 180° - 30° = 150°


.. admonition:: Exercise

   Calculate similar things when the ball hits a wall at left, right,
   top or bottom. Don't be arfaid to deal with angles between 180° and
   360°.


.. _unitcircletrig:

Trig (aka trigonometry) with the Unit Circle
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. admonition:: Problem

   A player moves to top-right at the angle of 60° measured from the
   x axis at 10 pixels per second. How many pixels should the player's x and y
   change every second?

   .. image:: images/playerproblem.png

Note that the y axis goes up in math so higher means bigger, but in programming
it's usually upside down.

Our problem has something to do with sine and cosine. The unit circle is a
circle with radius 1 placed in the middle of the xy plane. Here's a picture that
shows what sine and cosine are:

.. image:: images/unitcircle.png

This is really quite simple: the x coordinate is `\cos t` and the y
coordinate is `\sin t`. But the radius of the unit circle is 1 instead
of our 10, so we need to multiply everything by 10 to scale it up. We get this:

.. code-block:: python

   player.x += 10*cos(60)
   player.y += 10*sin(60)

Based on the unit circle, `\sin 60°` should be somewhere between 0 and 1 since
the height of the x axis is 0 and the circle's top is at 1 (the radius is 1).
But if we try this out in Python, something is wrong:

.. code-block:: python

   >>> import math
   >>> math.sin(60)
   -0.3048106211022167

Now you're feeling really WTF. The angles with negative sines should be below
the x axis, e.g. something between 180° and 360°.

The problem is that Python, Haskell, C and most other programming languages use
radians by default instead of degrees. Let's convert 60° to radians so the sine
function is happy:

.. code-block:: python

   >>> math.sin(math.radians(60))
   0.8660254037844386
   >>> math.cos(math.radians(60))
   0.5000000000000001

That's more like it. ``0.5000000000000001`` is obviously not an accurate
result, but it's good enough for a programmer while a mathematician would say
that `\sin 60° = \frac{\sqrt 3}2` and `\cos 60° = \frac 1 2`. I might write
more about radians, how the heck I came up with those mathy-accurate values and
how my conversion functions work some day.

Functions like `\sin` and `\cos` take radians as the argument, but also note
that some functions (like ``atan2``, see below) return radians.


.. _triangletrig:

Trig with a Triangle
~~~~~~~~~~~~~~~~~~~~

.. admonition:: Problem

   A player moves 10 pixels up and 20 pixels right. What angle is that?

Here's another way to define `\sin` and `\cos`, and another function called
`\tan` that we haven't used before.

.. image:: images/abcttriangle.png
   :align: right
.. math:: \sin t = \frac b c
.. math:: \cos t = \frac a c
.. math:: \tan t = \frac b a

These things only work if the triangle has a 90° corner, and the little box at
bottom right means that the corner is 90°. These definitions are compatible
with the unit circle stuff above; see :ref:`this <unitcircle-triangle-compat>`.

So now we know that `a=20` and `b=10`. Let's figure out how to calculate `t`
from those:

.. math:: \tan t = \frac b a
.. math:: t = \arctan{\frac b a} = \text{atan2}(b, a)

Here `\arctan` is the inverse of `\tan`, so `\arctan (\tan t) = t`. Most
programming languages have an ``atan(x)`` function that returns `\arctan x`,
but I don't recommend using it in this case; the ``atan2(b,a)`` function
returns `\arctan{\frac b a}` and I recommend it instead. ``atan2`` looks at the
signs of `a` and `b` and does the right thing if they're negative (the player
is moving to e.g. bottom left). It also works if ``a`` is 0 and ``b/a`` would
fail as division by zero is undefined.

.. note::
   Usually people like to put `x` before `y` in different kinds of places, but
   ``atan2`` is used like ``atan2(y_change, x_change)``, **not** like
   ``atan2(x_change, y_change)``.

Finally, it's time to calculate our stuff:

.. code-block:: python

   >>> from math import atan2, degrees
   >>> degrees(atan2(10, 20))
   26.56505117707799


.. _pythagoras:

Pythagorean Theorem
~~~~~~~~~~~~~~~~~~~

.. admonition:: Problem

   A player moves 10 pixels up and 20 pixels right, just like in the previous
   problem. How many pixels is that in total, measured diagonally?

.. image:: images/abctriangle.png
   :align: right

Here's a handy equation, also known as the Pythagorean theorem:

.. math:: a^2 + b^2 = c^2

Again, the triangle's corner between a and b must be 90° like it is in the
image. If you're wondering how the heck it works see
:ref:`this proof <pythagoras-proof>`.

Let's solve `c` from the equation by applying `\sqrt{\ \ }` on both sides:

.. math:: \sqrt{a^2 + b^2} = \sqrt{c^2} = |c| = c

Here `|c|` is :ref:`the absolute value <abs>`. The last step assumes `c \ge 0`,
but that's not a problem because a triangle with a negative side length doesn't
make much sense.

"Hypotenuse" is a fancy word that means the longest side of a triangle with a
90° angle, and that's why some programming languages have a ``hypot(a, b)``
function that returns `\sqrt{a^2 + b^2}`.

Let's calculate the distance:

.. code-block:: python

   >>> from math import hypot, sqrt
   >>> hypot(10, 20)
   22.360679774997898
   >>> sqrt(10**2 + 20**2)
   22.360679774997898

.. admonition:: Exercise

   Create a ball-and-paddle game.


Vectors
~~~~~~~

.. image:: images/ijab.png
   :align: right

A point is simply a pair of x and y coordinates, and a vector represents the
difference between two points. For example, if we have the points `A=(1,2)` and
`B=(3,5)`, the vector from A to B is
`\overrightarrow{AB} = (3-1) \bar i + (5-2) \bar j = 2 \bar i + 3 \bar j`. Here
`\bar i` and `\bar j` are vectors that go right and up by 1 unit, respectively.

A vector like `x \bar i + y \bar j` can be also written as `<x,y>`. Use
whatever style you want.

We could also use vectors to do similar things as in
:ref:`the unit circle trig section <unitcircletrig>`. The advantage with
vectors is that moving the player is really easy:

.. code-block:: python

   player.x += speed_vector.x
   player.y += speed_vector.y

A disadvantage is that if we want to change the angle that the player moves at
by 1° we can't just do ``moving_angle += 1``. We'll look into how this is done
below.

.. image:: images/ijplus.png
   :align: right

Another nice thing about vectors is that they can be +'ed together easily. For
example, if we first move 3 units to right, then 4 units up and finally 5 more
units to right, we move a total of 8 units to right and 4 units up. That's how
`3 \bar i + 4 \bar j + 5 \bar i = 8 \bar i + 4 \bar j`.

.. image:: images/vectorcalc.png
   :align: left

These vector calculations are just like the
:ref:`Pythagorean theorem <pythagoras>` and
:ref:`unit circle trig <unitcircletrig>` stuff above:

.. math:: l = \sqrt{a^2+b^2} = \text{hypot}(a, b)
.. math:: t = \text{atan2}(b,a)
.. math:: a = l \cdot \cos t
.. math:: b = l \cdot \sin t

Example: if we move 1 unit to the right and 2 units up, our vector is `<1,2>`,
its length is `\sqrt{1^2+2^2} = \sqrt 5 \approx 2.24` and the angle is
`\text{atan2}(2,1) \approx 63.4°`. On the other hand,
`2.24 \cdot \cos 63.4° \approx 1` and `2.24 \cdot \sin 63.4° \approx 2`.

One way to change the angle of a vector is to first convert it to a length and
an angle, change that angle and create a new vector. It looks like this in
pseudo-ish code:

.. code-block:: python

   length = hypot(speed_vector.x, speed_vector.y)
   angle = atan2(speed_vector.y, speed_vector.x) + angle_change
   speed_vector.x = cos(angle) * length
   speed_vector.y = sin(angle) * length

.. admonition:: Exercise

   Create a ``Vector`` class in your favorite programming language that
   represents `x \bar i + y \bar j`. The class should implement a
   ``Vector(x, y)`` constructor and the properties (or setters and getters if
   you use e.g. Java) ``x``, ``y``, ``length`` and ``angle``. Additionally, if
   the programming language supports it, you can add a nice ``"Vector(x, y)"``
   string representation and operator overloading; e.g.
   `(1 \bar i + 2 \bar j) + (3 \bar i + 4 \bar j) = 4 \bar i + 6 \bar j`, so
   ``Vector(1, 2) + Vector(3, 4) == Vector(4, 6)``.

   I found it easiest to implement things by storing only ``x`` and
   ``y`` and calculating everything else as needed.

   For example, here I'm playing with my Python implementation:

   .. code-block:: python

      >>> v = Vector(1, 2)
      >>> v         # the string representation
      Vector(1, 2)
      >>> v.x
      1
      >>> v.y
      2
      >>> v.length
      2.23606797749979
      >>> math.degrees(v.angle)
      63.43494882292201
      >>> v.angle = math.radians(45)
      >>> v
      Vector(1.5811388300841898, 1.5811388300841895)
      >>> v.length      # setting the angle didn't change this
      2.23606797749979
      >>> v.length = 0     # lol
      >>> v
      Vector(0.0, 0.0)

   My code is
   `here <https://github.com/Akuli/math-tutorial/blob/master/exercise-answers/vector.py>`_.
   I didn't add operator overloading because I wanted to keep the
   implementation simple and easy to read.


Hexadecimal Colors
~~~~~~~~~~~~~~~~~~

You might have seen weird colors before, like ``#ff0000`` is somehow magically
red or ``#0000ff`` is blue. This section is all about what the heck happens in
this color notation.

Let's start with an example. If we have a number like 2017, it really means this:

.. math::

   2017 &= 2 \cdot 1000 + 0 \cdot 100 + 1 \cdot 10 + 7 \\
        &= 2 \cdot 10^3 + 0 \cdot 10^2 + 1 \cdot 10^1 + 7 \cdot 10^0

The idea with **hexadecimal** is that instead of using 10 as a magic number we
use 16. That's why hexadecimal is also called **base 16**. But the problem is
that we only have 10 digits, 0 to 9, so we borrow a few letters so that A=10,
B=11, C=12, D=13, E=14 and F=15. For example:

.. math::

   \text{0xCAFE}  &= \text{0xC} \cdot 16^3 + \text{0xA} \cdot 16^2 +
                     \text{0xF} \cdot 16^1 + \text{0xE} \cdot 16^0 \\
                  &= 12 \cdot 16^3 + 10 \cdot 16^2 + 15 \cdot 16 + 14 \\
                  &= 51966

Here 0x means heXadecimal. Mathematicians don't use it, but I used it here
because it's very common in programming. Note that the first character is a
zero, not the letter O.

The sane way to calculate the last step is to use a programming interpreter or
calculator of your choice. Don't try to do it by hand.

Most programming languages have very good support for hexadecimal and a few
other bases. For example, here's Python:

.. code-block:: python

   >>> 0xcafe
   51966
   >>> 0xc * 16**3 + 0xa * 16**2 + 0xf * 16 + 0xe
   51966
   >>> 12 * 16**3 + 10 * 16**2 + 15 * 16 + 14
   51966
   >>> hex(51966)
   '0xcafe'
   >>> int('cafe', 16)
   51966
   >>> 'i went to a %x' % 51966
   'i went to a cafe'
   >>> 'i went to a {:x}'.format(51966)
   'i went to a cafe'

Now let's have a look at the colors. Another common way to represent colors is
``rgb(R,G,B)`` where R, G and B are red, green and blue values between
0 and 255. For example, ``rgb(255,0,0)`` is red because the red value is at
maximum and other values are 0. ``rgb(0,0,0)`` is black and
``rgb(255,255,255)`` is white.

You might have noticed that `0=\text{0x0}` and
`255 = 15 \cdot 16 + 15 = \text{0xFF}`, and that's not just a random
coincidence. A color like ``#RRGGBB`` is actually ``rgb(RR,GG,BB)`` where
``RR``, ``GG`` and ``BB`` are hexadecimal. For example,
``#ff0000 = rgb(0xff,0x00,0x00) = rgb(255,0,0)``.

Here's a Python program that converts RGB colors to hexadecimal and back:

.. code-block:: python

   def hex2rgb(hexcolor):
       assert len(hexcolor) == 7 and hexcolor[0] == '#'
       return (int(hexcolor[1:3], 16), int(hexcolor[3:5], 16), int(hexcolor[5:7], 16))

   def rgb2hex(r, g, b):
       # string formatting magic: %02x means hexadecimal padded with
       # zeros until it's at least 2 characters wide
       return '#%02x%02x%02x' % (r, g, b)

And here's a usage example:

.. code-block:: python

   >>> hex2rgb('#ff00ff')
   (255, 0, 255)
   >>> rgb2hex(255, 0, 255)
   '#ff00ff'

Note that most color parsers support specifying colors so that e.g. ``#f0f``
and ``#fff000fff`` are equivalent to ``#ff00ff``, but the above program doesn't
support that.
